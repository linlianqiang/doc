# 业务中台前端技术架构方案

## 1. 目标需求
-----
### 1.1 整体需求
* 用户体验：共同的Header、Aside并且Content中切换不同的服务，路由无感知刷新。
* 成本：技术栈统一、可复用组件和工具。
* 可扩展：服务进行解耦，拆分服务，服务可单独打包构建，不影响整个项目。
* 高可用：其他业务部门能根据现有模板快速开发。
* 兼容：除IE外的现代浏览器。
  
####  浏览器用户占比（2021年3月）

![img](https://ywnz.com/uploads/allimg/21/1-210406110139138.JPG)
  
   
### 1.2 移动端需求分析
   
| 方案        | 响应式 | 单独维护 | 
| ----------- | ----------- | -------------- | 
| 阿里云 | 展示内容做响应式    |     App           | 
| 腾讯云      | 展示内容做响应式   | 小程序（所有产品均有对应小程序）             | 
| 华为云      | 展示内容做响应式   | App             | 
| Unity      | 响应式   |      否        | 

#### 移动端需求结论
* 一套系统基本同时存在展示性部分和操作型部分。通过以上调研，展示型部分要兼容适配移动端。操作型部分保持与PC一致，通过滚动条滑动查看（禁止界面缩放，保持布局不乱），采用腾讯云方案。
* 移动端可以独立维护小程序。

## 2. 总体架构方案
-----
### 2.1 架构图
![前端架构图](media/中台架构设计图.png)

### 2.2 架构方案介绍
* 当前系统基于微前端的基座模式构建，采用qiankun作为应用间框架。
* 主框架采用vue2，子框架采用vue2、vue3。
* 通过vueCli脚手架打包，构建项目。通过vue.config.js定制化webpack。
* 通过eslint来强制约束前端代码。
  

## 3. 各个技术方案分析与对比
----

### 3.1 架构选型对比：传统项目（单页应用SPA）、微前端。

| 方案            | 独立构建 | 项目解耦 | 组件复用 | 技术栈是否统一 | 
| --------------- | ----------- | -------- | -------- | -------------- | 
| 单页应用SPA | 否   | 否       | 是       | 强制           | 
| 微前端          | 是   | 是       | 是       | 否             | 
#### 3.1.1 微前端简介
* 微前端是由后端微服务扩展而来的，优化前端大型的、不断臃肿的单页应用而延申出来的概念。通常有如下情况，会建议采用微前端：  
    * 原始单页应用过于臃肿、庞大，难以维护。又有新业务进行增量升级。
    * 多个部门联合开发系统中子应用。
    * 部门不同，导致的有可能技术栈不同。
* 微前端有两种模式：去中心化、基座模式。  
    * 基座模式：微前端的主流方案，核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问。  如下图：  
    * 
     ![基座示意图](./media/基座模式.png)
    * 去中心化：每个应用是单独部署在各自的服务器，每个应用都可以引用其他应用，也能被其他应用所引用，无中心应用的概念。
  
### 3.2 微前端具体实现方案描述

#### 3.2.1 iframe
* 浏览器原生支持，JS隔离、CSS隔离。
* 缺点：不同的域，无法通信。且样式难以控制。不建议使用
  
#### 3.2.2 SystemJS（海林）
* 基于标准的模块加载器。将组件构建成标准的浏览器可识别的模块规范。
* 非微前端方案，无法实现JS沙箱隔离，样式隔离。
  
#### 3.2.3 webComponent（Cocos Creator 方案）
由Google推出浏览器原生组件主要由以下三项技术组成：
* Custom elements（自定义元素）：一组JavaScript API，允许自定义标签。
* Shadow DOM（影子DOM）：一组JavaScript API，用于将封装的“影子”DOM树附加到元素，可以保持元素的功能私有，JS及CSS私有，而不用担心与文档的其他部分发生冲突。
* HTML templates（HTML模板）： template 元素可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。
* 客户端不存在兼容问题，浏览器存在兼容问题。
![webComponent](media/webComponent.png)

#### 3.2.4 Singer-SPA
* 成熟的且较早的微前端框架。非开箱即用框架，需要定制化。
* [官网推荐配置](https://zh-hans.single-spa.js.org/docs/recommended-setup)
##### 谁在用
* [UmiJS](https://umijs.org/zh-CN)
* [beamery](https://beamery.com/)
* [Telekom ](https://www.telekom.com/en)  
...
#### 3.2.5 qiankun
* 基于single-spa封装，提供了更加开箱即用的 API
* 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架
* HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单
* 样式隔离，确保微应用之间样式互相不干扰
* JS 沙箱，确保微应用之间 全局变量/事件 不冲突
* 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
  
##### 谁在用

* [蚂蚁金服](https://tech.antfin.com/)
* [百应](https://www.byai.com/)
* [云和恩墨](https://enmotech.com/)
* [花椒直播]  
...

#### 去中心化方案： webpack5:Module Federation（模块联邦）

* 基于Webpack5的新特性Module Federation实现，达到第三方依赖共享，减少不必要的代码引入的目的
* 跨技术栈组件式调用（模块共享），提供了在主应用框架中可以调用其他框架组件的能力
* 将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。
* EMP 是基于模块联邦实现的微前端框架。新概念，资源较少。


### 3.3 微前端具体实现方案对比

|  方案      | 文档    | 社区活跃度 | 更新频率 | Issues /  Star | 开箱即用 |
| ---------- | ------- | ---- | --------| -----  | ----- | 
| Singer-SPA    | 完善（英文/中文）  |   活跃   |  稳定更新 / v6.0.0-beta.1   | 6 / 9.4k  |  否 |
| qiankun       | 完善（英文/中文） |   活跃   |  稳定更新 / v2.4.3 | 119 / 10.1k  | 是 |
| EMP | 不完善 |   一般   | 稳定更新 / v1.8.24 | 6 / 1.1k | 是 |

### 3.4 UI库对比

|  方案      | 社区活跃度 / issues   | 组件数 | 团队  |  使用 | 
| ---------- | ------- | ---- | --------  | ----- | 
| ant-design-vue   | 中等 / 116  |   55   |  蚂蚁  | 14.4k  |
| elementUI      | 活跃 / 1.7k |   46   |  饿了么 |  50.1k  | 






